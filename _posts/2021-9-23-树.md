---
layout:     post
title:      算法与数据结构 (Algorithms and Data Structures)
subtitle:   
date:       2021-9-23
author:     月月鸟
header-img: img/tag-bg.jpg
catalog: true
tags:
    - Data Structure
---

# 1. 基本概念

二叉树（binary tree）是一种非线性数据结构，用于表示“祖先”与“后代”之间的层级关系，体现了“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含一个值、一个指向左子节点的引用和一个指向右子节点的引用。每个节点都有两个引用，分别指向左子节点和右子节点，而该节点则被称为这两个子节点的父节点。给定一个二叉树的节点时，该节点的左子节点及其以下节点形成的树称为左子树（left subtree），右子节点及其以下节点形成的树称为右子树（right subtree）。二叉树是一种树形数据结构，每个节点最多有两个子节点：左子节点和右子节点。二叉树广泛应用于计算机科学中，例如用于构建表达式树、决策树和二叉搜索树等。

- **节点（Node）**：
   - **值（Value）**：节点中存储的数据。
   - **左子节点（Left Child）**：当前节点的左边子树的根节点。
   - **右子节点（Right Child）**：当前节点的右边子树的根节点。

- **根节点（root node）**：位于二叉树顶层的节点，没有父节点。

- **叶节点（leaf node）**：没有子节点的节点，其两个指针均指向 `None`。

- **边（edge）**：连接两个节点的线段，即节点之间的引用（指针）。

- **节点所在的层（level）**：从顶至底递增，根节点所在层为第 1 层。

- **节点的度（degree）**：节点的子节点数量。在二叉树中，节点的度可以是 0、1 或 2。

- **二叉树的高度（height）**：从根节点到最远叶节点所经过的边的数量。

- **节点的深度（depth）**：从根节点到该节点所经过的边的数量。

- **节点的高度（height）**：从该节点到距离它最远的叶节点所经过的边的数量。

![这是图片](https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_terminology.png "Magic Gardens")

---

# 2. 二叉树的种类

1. **完全二叉树（Complete Binary Tree）**：
   - 除了最底层外，每一层的节点数都达到最大，并且最底层的节点都尽可能地靠左对齐。例如，在一个有 3 层的完全二叉树中，第一层和第二层的节点数都达到了最大，第三层的节点从左到右排列，可能不是完全填满的。每个节点的左右子树也都是完全二叉树。

2. **满二叉树（Full Binary Tree）**：
   - 每个节点要么有两个子节点，要么没有子节点。也就是说，所有的非叶节点都有两个子节点，而所有的叶节点都没有子节点。满二叉树是完全二叉树的一种特殊情况。


3. **平衡二叉树（Balanced Binary Tree）**：
   - 对于每一个节点，它的左右子树的高度差不超过 1。这种结构可以保证树的操作（如插入、删除、查找）在对数时间复杂度内完成。平衡二叉树的具体实现可以是 AVL 树或红黑树等。


4. **二叉搜索树（Binary Search Tree, BST）**：
   - 对于每一个节点，左子树的所有节点的值都小于该节点的值，右子树的所有节点的值都大于该节点的值。二叉搜索树用于快速查找、插入和删除操作。

5. **AVL树**：
   - 一种自平衡的二叉搜索树，任何节点的左右子树的高度差不超过 1。AVL 树通过旋转操作保持树的平衡，从而确保所有基本操作的时间复杂度为 O(log n)。

6. **红黑树（Red-Black Tree）**：
   - 一种自平衡的二叉搜索树，具有红黑性质来保证树的平衡性。每个节点都有一个颜色（红色或黑色），并且树满足特定的红黑性质，例如从根到任何叶节点的路径上，黑色节点的数量必须相同。这些性质帮助红黑树在插入和删除节点时维持平衡，保证操作的时间复杂度为 O(log n)。

---


# 3. 二叉树基本操作

## 3.1. 初始化二叉树

与链表类似，初始化二叉树需要创建节点并构建它们之间的引用（指针）。

**Python 代码示例**：

```python
# 定义二叉树节点类
class TreeNode:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# 初始化节点
n1 = TreeNode(val=1)
n2 = TreeNode(val=2)
n3 = TreeNode(val=3)
n4 = TreeNode(val=4)
n5 = TreeNode(val=5)

# 构建节点之间的引用（指针）
n1.left = n2
n1.right = n3
n2.left = n4
n2.right = n5
```

在这个示例中，我们创建了五个节点，并将它们连接起来，形成了如下结构的二叉树：

```
       1
      / \
     2   3
    / \
   4   5
```

## 3.2. 插入与删除节点

在二叉树中插入和删除节点涉及修改指针以更新树的结构。以下是插入和删除节点的操作示例：

**Python 代码示例**：

```python
# 定义二叉树节点类（与上面相同）
class TreeNode:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# 创建新节点 p
p = TreeNode(0)

# 在 n1 和 n2 之间插入节点 p
n1.left = p
p.left = n2

# 删除节点 p
n1.left = n2
```

在这个示例中：

1. **插入操作**：我们在节点 `n1` 的左子节点和 `n2` 之间插入了一个新节点 `p`，并将 `p` 的左子节点设置为 `n2`。插入后的树结构变为：

    ```
           1
          / \
         0   3
        / \
       2   5
      /
     4
    ```

2. **删除操作**：为了删除节点 `p`，我们需要将 `n1` 的左子节点重新设置为 `n2`，从而将 `p` 从树中移除。删除后的树结构恢复为原来的结构：

    ```
       1
      / \
     2   3
    / \
   4   5
    ```

**提示**：插入节点可能会改变二叉树的原有结构，而删除节点通常意味着删除该节点及其所有子树。因此，在进行插入和删除操作时，必须确保树的结构符合预期，并维护树的性质（如二叉搜索树的排序性质）。

![这是图片](https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_add_remove.png)

---

# 4. 二叉树遍历

二叉树遍历是对树中的节点进行访问和操作的一种方法。常见的二叉树遍历方式包括前序遍历、中序遍历和后序遍历。每种遍历方式都有其特定的访问顺序。

![这是图片](https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/binary_tree_dfs.png)

## 4.1. 前序遍历（Pre-order Traversal）

前序遍历的顺序是：访问根节点 → 遍历左子树 → 遍历右子树。

**Python 代码示例**：

```python
def pre_order_traversal(root):
    if root is None:
        return
    print(root.val)  # 访问根节点
    pre_order_traversal(root.left)  # 遍历左子树
    pre_order_traversal(root.right)  # 遍历右子树
```

**示例**：
对于以下二叉树：
```
       1
      / \
     2   3
    / \
   4   5
```
前序遍历的结果是：`1, 2, 4, 5, 3`

## 4.2. 中序遍历（In-order Traversal）

中序遍历的顺序是：遍历左子树 → 访问根节点 → 遍历右子树。

**Python 代码示例**：

```python
def in_order_traversal(root):
    if root is None:
        return
    in_order_traversal(root.left)  # 遍历左子树
    print(root.val)  # 访问根节点
    in_order_traversal(root.right)  # 遍历右子树
```

**示例**：
对于以下二叉树：
```
       1
      / \
     2   3
    / \
   4   5
```
中序遍历的结果是：`4, 2, 5, 1, 3`

## 4.3. 后序遍历（Post-order Traversal）

后序遍历的顺序是：遍历左子树 → 遍历右子树 → 访问根节点。

**Python 代码示例**：

```python
def post_order_traversal(root):
    if root is None:
        return
    post_order_traversal(root.left)  # 遍历左子树
    post_order_traversal(root.right)  # 遍历右子树
    print(root.val)  # 访问根节点
```

**示例**：
对于以下二叉树：
```
       1
      / \
     2   3
    / \
   4   5
```
后序遍历的结果是：`4, 5, 2, 3, 1`



## 4.4. 层次遍历（Level-order Traversal）

层次遍历也称为广度优先遍历，是按层次从上到下、从左到右遍历节点。通常使用队列来实现。

![这是图片](https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/binary_tree_bfs.png)

**Python 代码示例**：

```python
from collections import deque

def level_order_traversal(root):
    if root is None:
        return
    queue = deque([root])
    while queue:
        node = queue.popleft()
        print(node.val)  # 访问节点
        if node.left:
            queue.append(node.left)  # 将左子节点入队
        if node.right:
            queue.append(node.right)  # 将右子节点入队
```

**示例**：
对于以下二叉树：
```
       1
      / \
     2   3
    / \
   4   5
```
层次遍历的结果是：`1, 2, 3, 4, 5`






