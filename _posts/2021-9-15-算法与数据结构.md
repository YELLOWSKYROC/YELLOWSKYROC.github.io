---
layout:     post
title:      算法与数据结构 (Algorithms and Data Structures)
subtitle:   链表(4)
date:       2021-9-15
author:     月月鸟
header-img: img/tag-bg.jpg
catalog: true
tags:
    - Data Structure
---

链表（Linked List）是一种线性数据结构，由一组节点（Node）组成，每个节点包含数据域和指向下一个节点的指针（或引用）。链表具有灵活的内存分配方式，适用于需要频繁插入和删除操作的场景。下面详细解析链表的结构、类型、优缺点及其基本操作，并提供相应的 Python 代码示例。

### 链表的结构

每个节点通常包含两个部分：

1. **数据域（Data）：** 用于存储数据，可以是任何数据类型。
2. **指针域（Next）：** 存储指向下一个节点的指针（或引用）。

链表通过每个节点中的指针域连接在一起，从而形成一个链状结构。

### 链表的类型

1. **单向链表（Singly Linked List）：**
   - 每个节点只有一个指向下一个节点的指针。
   - 只能从头到尾顺序访问。

2. **双向链表（Doubly Linked List）：**
   - 每个节点有两个指针，分别指向前一个节点和后一个节点。
   - 可以双向遍历，访问更加灵活。

3. **循环链表（Circular Linked List）：**
   - 最后一个节点的指针指向第一个节点，形成一个环。
   - 可以是单向循环或双向循环链表。

### 链表的优缺点

**优点：**

- **动态大小：** 链表不需要预先分配固定大小的内存，可以根据需要动态增长。
- **快速插入和删除：** 在已知节点位置的情况下，插入和删除操作仅需修改指针，不需要移动其他元素。

**缺点：**

- **内存开销大：** 每个节点需要额外的指针域，占用更多内存。
- **访问速度慢：** 访问链表中的第n个元素需要从头遍历，平均时间复杂度为O(n)。







<!-- 
### 链表的基本操作

1. **插入节点：**
   - **在头部插入：** 创建新节点，并将其指针指向当前头节点，更新头节点指针。
   - **在尾部插入：** 遍历到最后一个节点，将其指针指向新节点。
   - **在中间插入：** 找到插入位置的前一个节点，调整指针以插入新节点。

2. **删除节点：**
   - **删除头节点：** 将头节点指针指向第二个节点。
   - **删除尾节点：** 遍历到倒数第二个节点，将其指针置空。
   - **删除中间节点：** 调整前一个节点的指针跳过被删除的节点。

3. **查找节点：**
   - 从头节点开始遍历，比较每个节点的数据域，找到目标节点。

4. **反转链表：**
   - 逐个反转每个节点的指针域，将链表从头到尾逆转。

### Python代码实现

以下是关于链表的一些基本操作的 Python 代码示例，包括节点的定义和链表的插入、删除、查找和反转操作。这些示例以单向链表为例。

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None

    def is_empty(self):
        return self.head is None

    def insert_at_head(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node

    def insert_at_tail(self, data):
        new_node = Node(data)
        if self.is_empty():
            self.head = new_node
            return
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node

    def insert_after(self, prev_data, data):
        current = self.head
        while current and current.data != prev_data:
            current = current.next
        if current is None:
            print("Previous node not found.")
            return
        new_node = Node(data)
        new_node.next = current.next
        current.next = new_node

    def delete_node(self, key):
        current = self.head
        if current and current.data == key:
            self.head = current.next
            current = None
            return
        prev = None
        while current and current.data != key:
            prev = current
            current = current.next
        if current is None:
            print("Node not found.")
            return
        prev.next = current.next
        current = None

    def search(self, key):
        current = self.head
        while current:
            if current.data == key:
                return True
            current = current.next
        return False

    def reverse(self):
        prev = None
        current = self.head
        while current:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node
        self.head = prev

    def print_list(self):
        current = self.head
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("None")

# 使用示例
ll = SinglyLinkedList()
ll.insert_at_head(3)
ll.insert_at_head(2)
ll.insert_at_tail(4)
ll.insert_after(2, 5)
ll.print_list()

ll.delete_node(3)
ll.print_list()

print("Found:", ll.search(4))

ll.reverse()
ll.print_list()
```

### 解释

- **插入操作：** 可以在链表的头部、尾部或指定节点后插入新节点。
- **删除操作：** 可以删除指定数据的节点，通过调整指针跳过该节点。
- **查找操作：** 从头节点开始遍历，寻找数据匹配的节点。
- **反转链表：** 通过逆转节点的指针方向，将链表从头到尾逆转。
- **打印链表：** 以箭头形式打印链表，从头节点开始依次输出每个节点的数据。


链表是一种重要的数据结构，广泛应用于实现其他数据结构和算法中。以下是链表在一些常见数据结构和算法中的应用：

### 单向链表的应用

1. **栈与队列：**
   - **栈（Stack）：** 当插入和删除操作都在链表的一端进行时，链表表现为先进后出的特性。可以用单向链表来实现栈，栈顶和链表的头部相对应。
   - **队列（Queue）：** 当插入操作在链表的一端进行，而删除操作在另一端进行时，链表表现为先进先出的特性。可以用单向链表实现队列，队尾插入和队头删除。

2. **哈希表：**
   - **链式地址法：** 解决哈希冲突的一种主流方案。哈希表中的每个槽位使用一个链表存储所有冲突的元素。

3. **图：**
   - **邻接表：** 表示图的一种常用方式，每个顶点与一个链表相关联，链表中的每个元素代表与该顶点相连的其他顶点。

### 双向链表的应用

1. **高级数据结构：**
   - **树结构：** 在红黑树、B 树等树结构中，需要快速访问节点的父节点，可以通过在节点中保存一个指向父节点的引用实现，类似于双向链表。

2. **浏览器历史：**
   - **前进/后退功能：** 用户在网页浏览器中点击前进或后退按钮时，需要知道前一个和后一个访问过的网页，双向链表的特性使得这种操作简单高效。

3. **LRU 算法：**
   - **缓存淘汰算法：** 在最近最少使用（LRU）算法中，需要快速找到最近最少使用的数据，以及支持快速添加和删除节点，双向链表非常适合这种场景。

### 环形链表的应用

1. **时间片轮转调度算法：**
   - **CPU调度：** 在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，需要对一组进程进行循环。环形链表适合实现这种循环操作。

2. **数据缓冲区：**
   - **音视频播放器：** 在某些数据缓冲区的实现中，数据流可能会被分成多个缓冲块并放入一个环形链表，以实现无缝播放。

这些应用展示了链表在不同场景中的灵活性和实用性。在实际开发中，根据具体需求选择合适的链表类型，可以显著提高程序的效率和性能。
 -->
